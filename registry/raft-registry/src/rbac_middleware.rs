use std::str::FromStr;

use auth::decode_token;
use common_utils::StringError;
use log::warn;
use poem::{error::{BadRequest, Forbidden}, Endpoint, Middleware, Request, Result};
use registry_provider::Credential;
use serde::Deserialize;
use uuid::Uuid;

pub struct RbacMiddleware;

impl<E: Endpoint> Middleware<E> for RbacMiddleware {
    type Output = RbacMiddlewareImpl<E>;

    fn transform(&self, ep: E) -> Self::Output {
        RbacMiddlewareImpl { ep }
    }
}

/// The new endpoint type generated by the TokenMiddleware.
pub struct RbacMiddlewareImpl<E> {
    ep: E,
}

const TOKEN_HEADER: &str = "Authorization";
const DEBUG_TOKEN_HEADER: &str = "x-feathr-debug-token";

#[derive(Default, Deserialize)]
#[serde(default)]
struct Claims {
    app_id: Option<String>,
    preferred_username: Option<String>,
    email: Option<String>,
}

impl Claims {
    fn get_credential(&self) -> Result<Credential> {
        match &self.app_id {
            Some(s) => {
                let id: Uuid = s.parse().map_err(|e| BadRequest(e))?;
                Ok(Credential::App(id))
            }
            None => match &self.preferred_username {
                Some(s) => Ok(Credential::User(s.to_owned())),
                None => match &self.email {
                    Some(s) => Ok(Credential::User(s.to_owned())),
                    None => Err(BadRequest(StringError::new("Invalid token claims"))),
                },
            },
        }
    }
}

#[poem::async_trait]
impl<E: Endpoint> Endpoint for RbacMiddlewareImpl<E> {
    type Output = E::Output;

    async fn call(&self, mut req: Request) -> Result<Self::Output> {
        if std::env::var("ENABLE_RBAC").is_err() {
            req.extensions_mut().insert(Credential::RbacDisabled);
        } else if std::env::var("FEATHR_ENABLE_RBAC_DEBUG_MUST_NOT_USE_IN_PROD").unwrap_or_default()
            == "feathr_rbac_debug_enabled"
        {
            warn!("RBAC debug enabled");
            if let Some(value) = req
                .headers()
                .get(DEBUG_TOKEN_HEADER)
                .and_then(|value| value.to_str().ok())
            {
                if let Ok(credential) = Credential::from_str(value) {
                    warn!(
                        "RBAC debug enabled, got credential from debug header: {:?}",
                        credential
                    );
                    req.extensions_mut().insert(credential);
                }
            } else if let Some(value) = req
                .headers()
                .get(TOKEN_HEADER)
                .and_then(|value| value.to_str().ok())
            {
                let value = value.trim_start_matches("Bearer");
                let claims: Claims = decode_token(value).await.map_err(|e| BadRequest(e))?;
                req.extensions_mut().insert(claims.get_credential()?);
            }
        } else if let Some(value) = req
            .headers()
            .get(TOKEN_HEADER)
            .and_then(|value| value.to_str().ok())
        {
            let value = value.trim_start_matches("Bearer");
            let claims: Claims = decode_token(value).await.map_err(|e| BadRequest(e))?;
            req.extensions_mut().insert(claims.get_credential()?);
        } else {
            return Err(Forbidden(StringError::new("Missing token")));
        }

        // call the next endpoint.
        self.ep.call(req).await
    }
}
